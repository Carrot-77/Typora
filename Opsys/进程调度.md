# 进程调度



## 进程的三种基本状态

（1）**运行**：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。

（2）**就绪**：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。

（3）**阻塞**：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

![img](https://img-blog.csdnimg.cn/20190519185029368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbml4aW4=,size_16,color_FFFFFF,t_70)



## 调度器



### 完全公平调度器CFS

（linux2.6增加的调度方法）

CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据nice值来计算的。nice值的范围从 -20 到 +19，数值较低的nice值表示较高的相对优先级。具有较低nice值的任务，与具有较高nice值的任务相比，会得到更高比例的处理器处理时间。默认nice值为 0。

* 为了确定每个进程真实的执行时间，引入目标延迟，目标延迟是调度的固定周期

* 为了避免因为目标延迟设置过小导致每个进程时间过短，引入最小粒度



### 抢占式

抢占式调度器确定一个线程正常轮到这个线程的cpu时间用完时，会暂停这个线程，将cpu控制权交给轮到时间的另外一个线程。目前大多数虚拟机都使用这种方式的线程调度器。

### 协作式

 协作式线程调度器在将cpu控制权交给其他线程钱，会等待正在运行的线程自己去暂停，然后才可以交给另外一个线程。一些早期或者特殊用途的虚拟机可能会使用这种方式。

两者区别：

与使用抢占式线程调度的虚拟机相比，使用协作式线程调度器的虚拟机更容易使线程陷入饥饿，因为一个该优先级的非协作线程会独占整个CPU。



## 时间片

时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。



## IO约束型和CPU约束型

### IO约束型的任务

多数时间处于堵塞状态或等待资源的进程，需要更短的时间片

经常要进行IO操作的任务，这些任务每次使用CPU的时间短，但是频率高，相应的优先级就得高，这样才能实现CPU与IO的并行操作。



### CPU约束型的任务

一直消耗完可用的时间片的进程，期望获得更长的时间片

每次使用CPU的时间都比较长，切换次数少，这样的任务就优先级就相对低一些；其实前台任务就属于IO约束型任务，后台任务属于CPU约束型任务



## sched_yield

sched_yield()会主动放弃当前CPU给其他进程使用；但是如果当前CPU上无其他进程等待执行，则直接返回继续执行当前进程。

调用sched_yield()之后当前进程会被移动到进程优先级等待队列尾部，让相同或者更高优先级进程运行。

sched_yield()这个函数可以使用另一个级别等于或高于当前线程的线程先运行。如果没有符合条件的线程，那么这个函数将会立刻返回然后继续执行当前线程的程序。 

而sleep则是等待一定时间后等待CPU的调度，然后去获得CPU资源（这也是usleep()为什么不准的原因）。

有策略的调用sched_yield()能在资源竞争情况很严重时，通过给其他的线程或进程运行机会的方式来提升程序的性能。也就是说，调用sched_yield()能让你的当前线程让出资源，通过一定的策略调用sched_yield()满足你的业务要求可以保证各个线程或进程都有机会运行。



## nice



### nice命令

> nice [OPTION] [command [arguments...]]

在当前程序运行优先级基础之上调整指定值得到新的程序运行优先级，用新的程序运行优先级运行命令行"command[arguments...]"。优先级的范围为-20 ～ 19 等40个等级，其中数值越小优先级越高，数值越大优先级越低，既-20的优先级最高， 19的优先级最低。若调整后的程序运行优先级高于-20，则就以优先级-20来运行命令行；若调整后的程序运行优先级低于19，则就以优先级19来运行命令行。若 nice命令未指定优先级的调整值，则以缺省值10来调整程序运行优先级，既在当前程序运行优先级基础之上增加10。



### nice函数

```c
#include<unistd.h >
int nice(int inc);
```

进程调度优先级为，nice的取值范围是0~（2*NZERO）-1

一般头文件会定义：优先级的最大值NZERO;

 如果没有可以通过这个函数得到：sysconf(_SC_NZERO);



输入：输入参数inc时，inc会以加的形式，设置优先级如：原理优先级为1，而inc为2，则优先级为3，若inc为-1，则优先级为0

输出：成功设置输出inc的值，错误返回-1

* 创建一个子进程，打印父进程和子进程优先级
* 子进程通过nice函数设置进程优先级



## getpriority

```c
int getpriority(int which, int who);
//返回一组进程的优先级
```

参数which和who确定返回哪一组进程的优先级

* PRIO_PROCESS，一个特定的进程，此时who的取值为进程ID  
* PRIO_PGRP，一个进程组的所有进程，此时who的取值为进程组的ID
* PRIO_USER，一个用户拥有的所有进程，此时who的取值为实际用户ID

getpriority如果出错返回-1，并且设置errno的值，errno的值可能是：

 EINVAL which was not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.。which是一个无效的值

 

## oprio_set 



获取/设置I / O调度类和优先级

```c
int ioprio_get(int which, int who);
int ioprio_set(int which, int who, int ioprio);
```

