由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：

P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行

V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。

## semget()

它的作用是创建一个新信号量或取得一个已有信号量，原型为：

> int semget(key_t key, int num_sems, int sem_flags);

* 第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键，所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。

* 第二个参数num_sems指定需要的信号量数目，它的值几乎总是1。

* 第三个参数sem_flags是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。

semget()函数成功返回一个相应信号标识符（非零），失败返回-1.

## **semop()**

它的作用是改变信号量的值，原型为：

> int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);

sem_id是由semget()返回的信号量标识符，sembuf结构的定义如下：

```
`struct` `sembuf{``    ``short` `sem_num; ``// 除非使用一组信号量，否则它为0``    ``short` `sem_op;  ``// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，``                   ``// 一个是+1，即V（发送信号）操作。``    ``short` `sem_flg; ``// 通常为SEM_UNDO,使操作系统跟踪信号，``                   ``// 并在进程没有释放该信号量而终止时，操作系统释放信号量``};`
```

## **semctl()**

该函数用来直接控制信号量信息，它的原型为：

> int semctl(int sem_id, int sem_num, int command, ...);

如果有第四个参数，它通常是一个union semum结构，定义如下：

```
`union` `semun {``    ``int` `val;``    ``struct` `semid_ds *buf;``    ``unsigned ``short` `*arry;``};`
```

前两个参数与前面一个函数中的一样，command通常是下面两个值中的其中一个

SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。

IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。